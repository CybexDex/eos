/**
 *  @file
 *  @copyright defined in eos/LICENSE.txt
 */
#include <zmq.hpp>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


#include <eosio/zmq_plugin/zmq_plugin.hpp>
#include <eosio/chain/eosio_contract.hpp>
#include <eosio/chain/config.hpp>
#include <eosio/chain/exceptions.hpp>
#include <eosio/chain/transaction.hpp>
#include <eosio/chain/types.hpp>

#include <fc/io/json.hpp>
#include <fc/utf8.hpp>
#include <fc/variant.hpp>

#include <boost/algorithm/string.hpp>
#include <boost/chrono.hpp>
#include <boost/signals2/connection.hpp>
#include <boost/thread/thread.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/thread/condition_variable.hpp>

#include <queue>




namespace fc { class variant; }
namespace eosio {
	
using chain::account_name;
using chain::action_name;
using chain::block_id_type;
using chain::permission_name;
using chain::transaction;
using chain::signed_transaction;
using chain::signed_block;
using chain::transaction_id_type;
using chain::packed_transaction;


static appbase::abstract_plugin& _zmq_plugin = app().register_plugin<zmq_plugin>();
class zmq_plugin_impl {
public:
	zmq_plugin_impl();
	~zmq_plugin_impl();
	struct action_trace_struct{
		chain::action_trace	base;
		string trx_status;
	};
   typedef vector<action_trace_struct>  bulk_write;
	struct pub_key_struct{
		string account;
		string public_key;
		string permission;
	};
   
   typedef vector<pub_key_struct>  pub_keys;

   fc::optional<boost::signals2::scoped_connection> accepted_block_connection;
   fc::optional<boost::signals2::scoped_connection> irreversible_block_connection;
   fc::optional<boost::signals2::scoped_connection> accepted_transaction_connection;
   fc::optional<boost::signals2::scoped_connection> applied_transaction_connection;

   void consume_blocks();

   void accepted_block( const chain::block_state_ptr& );
   void applied_irreversible_block(const chain::block_state_ptr&);
   void accepted_transaction(const chain::transaction_metadata_ptr&);
   void applied_transaction(const chain::transaction_trace_ptr&);
   void process_accepted_transaction(const chain::transaction_metadata_ptr&);
   void _process_accepted_transaction(const chain::transaction_metadata_ptr&);
   void process_applied_transaction(const chain::transaction_trace_ptr&);
   void _process_applied_transaction(const chain::transaction_trace_ptr&);
   void process_accepted_block( const chain::block_state_ptr& );
   void _process_accepted_block( const chain::block_state_ptr& );
   void process_irreversible_block(const chain::block_state_ptr&);
   void _process_irreversible_block(const chain::block_state_ptr&);



   bool add_action_trace( bulk_write& bulk_action_traces, const chain::action_trace& atrace,
                          const chain::transaction_trace_ptr& t,
                          bool executed, const std::chrono::milliseconds& now,
                          bool& write_ttrace );

   void update_account(const chain::action& act);

   void add_pub_keys( const vector<chain::key_weight>& keys, const account_name& name,
                      const permission_name& permission, const std::chrono::milliseconds& now );
   void init();

   // zmq::context_t * context;
   zmq::socket_t * publisher;

   template<typename Queue, typename Entry> void queue(Queue& queue, const Entry& e);

   bool configured{false};
   bool is_store_table{false};
   uint32_t start_block_num = 0;
   std::atomic_bool start_block_reached{false};

   bool is_producer = false;
   bool update_blocks_via_block_num = false;
   bool store_blocks = true;
   bool store_block_states = true;
   bool store_transactions = true;
   bool store_transaction_traces = true;
   bool store_action_traces = true;


   // consum thread
   size_t max_queue_size = 0;
   int queue_sleep_time = 0;
   std::deque<chain::transaction_metadata_ptr> transaction_metadata_queue;
   std::deque<chain::transaction_metadata_ptr> transaction_metadata_process_queue;
   std::deque<chain::transaction_trace_ptr> transaction_trace_queue;
   std::deque<chain::transaction_trace_ptr> transaction_trace_process_queue;
   std::deque<chain::block_state_ptr> block_state_queue;
   std::deque<chain::block_state_ptr> block_state_process_queue;
   std::deque<chain::block_state_ptr> irreversible_block_state_queue;
   std::deque<chain::block_state_ptr> irreversible_block_state_process_queue;
   boost::mutex mtx;
   boost::condition_variable condition;
   boost::thread consume_thread;
   std::atomic_bool done{false};
   std::atomic_bool startup{true};
   fc::optional<chain::chain_id_type> chain_id;


   static const action_name newaccount;
   static const action_name setabi;
   static const action_name updateauth;
   static const action_name deleteauth;
   static const permission_name owner;
   static const permission_name active;

};

const action_name zmq_plugin_impl::newaccount = chain::newaccount::get_name();
const action_name zmq_plugin_impl::setabi = chain::setabi::get_name();
const action_name zmq_plugin_impl::updateauth = chain::updateauth::get_name();
const action_name zmq_plugin_impl::deleteauth = chain::deleteauth::get_name();
const permission_name zmq_plugin_impl::owner = chain::config::owner_name;
const permission_name zmq_plugin_impl::active = chain::config::active_name;


template<typename Queue, typename Entry>
void zmq_plugin_impl::queue( Queue& queue, const Entry& e ) {
   boost::mutex::scoped_lock lock( mtx );
   auto queue_size = queue.size();
   if( queue_size > max_queue_size ) {
       lock.unlock();
       condition.notify_one();
       queue_sleep_time += 10;
       if( queue_sleep_time > 1000 )
          wlog("queue size: ${q}", ("q", queue_size));
       boost::this_thread::sleep_for( boost::chrono::milliseconds( queue_sleep_time ));
       lock.lock();
   } else {
      queue_sleep_time -= 10;
      if( queue_sleep_time < 0 ) queue_sleep_time = 0;
   }
   queue.emplace_back( e );
   lock.unlock();
   condition.notify_one();
}



void zmq_plugin_impl::accepted_transaction( const chain::transaction_metadata_ptr& t ) {
   try {
      if( store_transactions ) {
         queue( transaction_metadata_queue, t );
      }
   } catch (fc::exception& e) {
      elog("FC Exception while accepted_transaction ${e}", ("e", e.to_string()));
   } catch (std::exception& e) {
      elog("STD Exception while accepted_transaction ${e}", ("e", e.what()));
   } catch (...) {
      elog("Unknown exception while accepted_transaction");
   }
}

void zmq_plugin_impl::applied_transaction( const chain::transaction_trace_ptr& t ) {
   try {
      // Traces emitted from an incomplete block leave the producer_block_id as empty.
      //
      // Avoid adding the action traces or transaction traces to the database if the producer_block_id is empty.
      // This way traces from speculatively executed transactions are not included in the Mongo database which can
      // avoid potential confusion for consumers of that database.
      //
      // Due to forks, it could be possible for multiple incompatible action traces with the same block_num and trx_id
      // to exist in the database. And if the producer double produces a block, even the block_time may not
      // disambiguate the two action traces. Without a producer_block_id to disambiguate and determine if the action
      // trace comes from an orphaned fork branching off of the blockchain, consumers of the Mongo DB database may be
      // reacting to a stale action trace that never actually executed in the current blockchain.
      //
      // It is better to avoid this potential confusion by not logging traces from speculative execution, i.e. emitted
      // from an incomplete block. This means that traces will not be recorded in speculative read-mode, but
      // users should not be using the zmq_plugin in that mode anyway.
      //
      // Allow logging traces if node is a producer for testing purposes, so a single nodeos can do both for testing.
      //
      // It is recommended to run zmq_plugin in read-mode = read-only.
      //
      if( !is_producer && !t->producer_block_id.valid() ){
	      elog("producer enabled!");
         return;
      }
      // always queue since account information always gathered
      queue( transaction_trace_queue, t );
   } catch (fc::exception& e) {
      elog("FC Exception while applied_transaction ${e}", ("e", e.to_string()));
   } catch (std::exception& e) {
      elog("STD Exception while applied_transaction ${e}", ("e", e.what()));
   } catch (...) {
      elog("Unknown exception while applied_transaction");
   }
}

void zmq_plugin_impl::applied_irreversible_block( const chain::block_state_ptr& bs ) {
   try {
      if( store_blocks || store_block_states || store_transactions ) {
         queue( irreversible_block_state_queue, bs );
      }
   } catch (fc::exception& e) {
      elog("FC Exception while applied_irreversible_block ${e}", ("e", e.to_string()));
   } catch (std::exception& e) {
      elog("STD Exception while applied_irreversible_block ${e}", ("e", e.what()));
   } catch (...) {
      elog("Unknown exception while applied_irreversible_block");
   }
}

void zmq_plugin_impl::accepted_block( const chain::block_state_ptr& bs ) {
   try {
      if( !start_block_reached ) {
         if( bs->block_num >= start_block_num ) {
            start_block_reached = true;
         }
      }
      if( store_blocks || store_block_states ) {
         queue( block_state_queue, bs );
      }
   } catch (fc::exception& e) {
      elog("FC Exception while accepted_block ${e}", ("e", e.to_string()));
   } catch (std::exception& e) {
      elog("STD Exception while accepted_block ${e}", ("e", e.what()));
   } catch (...) {
      elog("Unknown exception while accepted_block");
   }
}

void zmq_plugin_impl::consume_blocks() {
   try {

      while (true) {
         boost::mutex::scoped_lock lock(mtx);
         while ( transaction_metadata_queue.empty() &&
                 transaction_trace_queue.empty() &&
                 block_state_queue.empty() &&
                 irreversible_block_state_queue.empty() &&
                 !done ) {
            condition.wait(lock);
         }

         // capture for processing
         size_t transaction_metadata_size = transaction_metadata_queue.size();
         if (transaction_metadata_size > 0) {
            transaction_metadata_process_queue = move(transaction_metadata_queue);
            transaction_metadata_queue.clear();
         }
         size_t transaction_trace_size = transaction_trace_queue.size();
         if (transaction_trace_size > 0) {
            transaction_trace_process_queue = move(transaction_trace_queue);
            transaction_trace_queue.clear();
         }
         size_t block_state_size = block_state_queue.size();
         if (block_state_size > 0) {
            block_state_process_queue = move(block_state_queue);
            block_state_queue.clear();
         }
         size_t irreversible_block_size = irreversible_block_state_queue.size();
         if (irreversible_block_size > 0) {
            irreversible_block_state_process_queue = move(irreversible_block_state_queue);
            irreversible_block_state_queue.clear();
         }

         lock.unlock();

         if (done) {
            ilog("draining queue, size: ${q}", ("q", transaction_metadata_size + transaction_trace_size + block_state_size + irreversible_block_size));
         }

         // process transactions
         auto start_time = fc::time_point::now();
         auto size = transaction_trace_process_queue.size();
         while (!transaction_trace_process_queue.empty()) {
            const auto& t = transaction_trace_process_queue.front();
            process_applied_transaction(t);
            transaction_trace_process_queue.pop_front();
         }
         auto time = fc::time_point::now() - start_time;
         auto per = size > 0 ? time.count()/size : 0;
         if( time > fc::microseconds(500000) ) // reduce logging, .5 secs
            ilog( "process_applied_transaction,  time per: ${p}, size: ${s}, time: ${t}", ("s", size)("t", time)("p", per) );

         start_time = fc::time_point::now();
         size = transaction_metadata_process_queue.size();
         while (!transaction_metadata_process_queue.empty()) {
            const auto& t = transaction_metadata_process_queue.front();
            process_accepted_transaction(t);
            transaction_metadata_process_queue.pop_front();
         }
         time = fc::time_point::now() - start_time;
         per = size > 0 ? time.count()/size : 0;
         if( time > fc::microseconds(500000) ) // reduce logging, .5 secs
            ilog( "process_accepted_transaction, time per: ${p}, size: ${s}, time: ${t}", ("s", size)( "t", time )( "p", per ));

         // process blocks
         start_time = fc::time_point::now();
         size = block_state_process_queue.size();
         while (!block_state_process_queue.empty()) {
            const auto& bs = block_state_process_queue.front();
            process_accepted_block( bs );
            block_state_process_queue.pop_front();
         }
         time = fc::time_point::now() - start_time;
         per = size > 0 ? time.count()/size : 0;
         if( time > fc::microseconds(500000) ) // reduce logging, .5 secs
            ilog( "process_accepted_block,       time per: ${p}, size: ${s}, time: ${t}", ("s", size)("t", time)("p", per) );

         // process irreversible blocks
         start_time = fc::time_point::now();
         size = irreversible_block_state_process_queue.size();
         while (!irreversible_block_state_process_queue.empty()) {
            const auto& bs = irreversible_block_state_process_queue.front();
            process_irreversible_block(bs);
            irreversible_block_state_process_queue.pop_front();
         }
         time = fc::time_point::now() - start_time;
         per = size > 0 ? time.count()/size : 0;
         if( time > fc::microseconds(500000) ) // reduce logging, .5 secs
            ilog( "process_irreversible_block,   time per: ${p}, size: ${s}, time: ${t}", ("s", size)("t", time)("p", per) );

         if( transaction_metadata_size == 0 &&
             transaction_trace_size == 0 &&
             block_state_size == 0 &&
             irreversible_block_size == 0 &&
             done ) {
            break;
         }
      }
      ilog("consume thread shutdown gracefully");
   } catch (fc::exception& e) {
      elog("FC Exception while consuming block ${e}", ("e", e.to_string()));
   } catch (std::exception& e) {
      elog("STD Exception while consuming block ${e}", ("e", e.what()));
   } catch (...) {
      elog("Unknown exception while consuming block");
   }
}


void zmq_plugin_impl::process_accepted_transaction( const chain::transaction_metadata_ptr& t ) {
   try {
      if( start_block_reached ) {
         _process_accepted_transaction( t );
      }
   } catch (fc::exception& e) {
      elog("FC Exception while processing accepted transaction metadata: ${e}", ("e", e.to_detail_string()));
   } catch (std::exception& e) {
      elog("STD Exception while processing accepted tranasction metadata: ${e}", ("e", e.what()));
   } catch (...) {
      elog("Unknown exception while processing accepted transaction metadata");
   }
}

void zmq_plugin_impl::process_applied_transaction( const chain::transaction_trace_ptr& t ) {
   try {
      // always call since we need to capture setabi on accounts even if not storing transaction traces
      _process_applied_transaction( t );
   } catch (fc::exception& e) {
      elog("FC Exception while processing applied transaction trace: ${e}", ("e", e.to_detail_string()));
   } catch (std::exception& e) {
      elog("STD Exception while processing applied transaction trace: ${e}", ("e", e.what()));
   } catch (...) {
      elog("Unknown exception while processing applied transaction trace");
   }
}

void zmq_plugin_impl::process_irreversible_block(const chain::block_state_ptr& bs) {
  try {
     if( start_block_reached ) {
        _process_irreversible_block( bs );
     }
  } catch (fc::exception& e) {
     elog("FC Exception while processing irreversible block: ${e}", ("e", e.to_detail_string()));
  } catch (std::exception& e) {
     elog("STD Exception while processing irreversible block: ${e}", ("e", e.what()));
  } catch (...) {
     elog("Unknown exception while processing irreversible block");
  }
}

void zmq_plugin_impl::process_accepted_block( const chain::block_state_ptr& bs ) {
   try {
      if( start_block_reached ) {
         _process_accepted_block( bs );
      }
   } catch (fc::exception& e) {
      elog("FC Exception while processing accepted block trace ${e}", ("e", e.to_string()));
   } catch (std::exception& e) {
      elog("STD Exception while processing accepted block trace ${e}", ("e", e.what()));
   } catch (...) {
      elog("Unknown exception while processing accepted block trace");
   }
}

void zmq_plugin_impl::_process_accepted_transaction( const chain::transaction_metadata_ptr& t ) {
   const auto& trx = t->trx;

   auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
         std::chrono::microseconds{fc::time_point::now().time_since_epoch().count()} );
   
   const auto& trx_id = t->id;
   const auto trx_id_str = trx_id.str();


   string signing_keys_json;
   if( t->signing_keys.valid() ) {
      signing_keys_json = fc::json::to_string( t->signing_keys->second );
   } else {
      auto signing_keys = trx.get_signature_keys( *chain_id, false, false );
      if( !signing_keys.empty() ) {
         signing_keys_json = fc::json::to_string( signing_keys );
      }
   }
   auto trx_json = "accepted_transaction " +fc::json::to_string(trx);

   try {
	   zmq::message_t message(trx_json.size());
	   memcpy (message.data(), trx_json.data(), trx_json.size());
	   publisher->send(message);
   } catch( std::exception &e ) {
      elog( "Unable to send transaction JSON to zmq : ${e}", ("e", e.what()) );
      elog( "  JSON: ${j}", ("j", trx_json) );
   }


}

bool
zmq_plugin_impl::add_action_trace( bulk_write& bulk_action_traces, const chain::action_trace& atrace,
                                        const chain::transaction_trace_ptr& t,
                                        bool executed, const std::chrono::milliseconds& now,
                                        bool& write_ttrace )
{

   if( executed && atrace.receipt.receiver == chain::config::system_account_name ) {
      update_account( atrace.act );
   }

   bool added = false;
   write_ttrace |= (store_action_traces || store_transaction_traces) && start_block_reached;
   if( start_block_reached && store_action_traces ) {
      const chain::base_action_trace& base = atrace; // without inline action traces
      action_trace_struct action_trace;

      action_trace.base = atrace;

      if( t->receipt.valid() ) {
	      action_trace.trx_status = std::string( t->receipt->status ) ;
      }
      // action_trace_json = fc::json::to_string(action_trace);
      bulk_action_traces.push_back(action_trace);

      // bulk_action_traces.append( insert_op );
      added = true;
   }

   for( const auto& iline_atrace : atrace.inline_traces ) {
      added |= add_action_trace( bulk_action_traces, iline_atrace, t, executed, now, write_ttrace );
   }

   return added;
}


void zmq_plugin_impl::_process_applied_transaction( const chain::transaction_trace_ptr& t ) {

   auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
         std::chrono::microseconds{fc::time_point::now().time_since_epoch().count()});
   bulk_write bulk_action_traces;
   bool write_atraces = false;
   bool write_ttrace = false; // filters apply to transaction_traces as well
   bool executed = t->receipt.valid() && t->receipt->status == chain::transaction_receipt_header::executed;

   for( const auto& atrace : t->action_traces ) {
      try {
         write_atraces |= add_action_trace( bulk_action_traces, atrace, t, executed, now, write_ttrace );
      } catch(...) {
      }
   }

   if( !start_block_reached ) return; //< add_action_trace calls update_account which must be called always

	zmq::message_t message;
   // transaction trace insert

   if( store_transaction_traces && write_ttrace ) {
      try {
	auto ats = *t;
	auto ats_json = "applied_transaction_trantrace " + fc::json::to_string(ats);
	message.rebuild(ats_json.size());
	memcpy (message.data(), ats_json.data(), ats_json.size());
	publisher->send(message);
      } catch( ... ) {
      }
   }
   // insert action_traces
   if( write_atraces ) {
      try {
	 for(auto b : bulk_action_traces){
	 	auto bulk_action_traces_json = "applied_transaction_action_trace " + fc::json::to_string(b);
	 	message.rebuild(bulk_action_traces_json.size());
	 	memcpy (message.data(), bulk_action_traces_json.data(), bulk_action_traces_json.size());
	 	publisher->send(message);
	 }
      } catch( ... ) {
      }
   }

}

void zmq_plugin_impl::_process_accepted_block( const chain::block_state_ptr& bs ) {

   auto block_num = bs->block_num;
   if( block_num % 1000 == 0 )
      ilog( "block_num: ${b}", ("b", block_num) );
   const auto& block_id = bs->id;
   const auto block_id_str = block_id.str();
   zmq::message_t message;

   auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
         std::chrono::microseconds{fc::time_point::now().time_since_epoch().count()});

   if( store_block_states ) {

      const chain::block_header_state& bhs = *bs;

      auto json = "block_header_state " + fc::json::to_string( bhs );
      try {
	message.rebuild(json.size());
	memcpy (message.data(), json.data(), json.size());
	publisher->send(message);

      } catch( std::exception& e) {
           elog( "Unable to send block_header_state JSON : ${e}", ("e", e.what()) );
           elog( "  JSON: ${j}", ("j", json) );
      }

  }

   if( store_blocks ) {
      auto sblk = *bs->block;
      auto json = "block " + fc::json::to_string(sblk);
      try {
	message.rebuild(json.size());
	memcpy (message.data(), json.data(), json.size());
	publisher->send(message);
      } catch( std::exception& e) {
           elog( "Unable to send block JSON : ${e}", ("e", e.what()) );
           elog( "  JSON: ${j}", ("j", json) );
      }

  }
}

void zmq_plugin_impl::_process_irreversible_block(const chain::block_state_ptr& bs)
{

   const auto block_id = bs->block->id();
   const auto block_id_str = block_id.str();

   auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
         std::chrono::microseconds{fc::time_point::now().time_since_epoch().count()});

   // _process_accepted_block( bs );
   zmq::message_t message;
   auto json = "irreversible_block " + fc::json::to_string( *bs->block);
   message.rebuild(json.size());
   memcpy (message.data(), json.data(), json.size());
   publisher->send(message);
	
   if( store_transactions ) {
      const auto block_num = bs->block->block_num();
      bool transactions_in_block = false;

      for( const auto& receipt : bs->block->transactions ) {
         string trx_id_str;
         if( receipt.trx.contains<packed_transaction>() ) {
            const auto& pt = receipt.trx.get<packed_transaction>();
            // get id via get_raw_transaction() as packed_transaction.id() mutates internal transaction state
            const auto& raw = pt.get_raw_transaction();
            const auto& trx = fc::raw::unpack<transaction>( raw );
            const auto& id = trx.id();
	    auto trx_json = "irreversible_trx " + fc::json::to_string(trx);
            message.rebuild(trx_json.size());
	    memcpy (message.data(), trx_json.data(), trx_json.size());
   	    publisher->send(message);
	    trx_id_str = id.str();
         } else {
            const auto& id = receipt.trx.get<transaction_id_type>();
            trx_id_str = id.str();
         }

         transactions_in_block = true;
      }

      if( transactions_in_block ) {
         try {
		 // send
        } catch( ... ) {
         }
      }
   }
}

void zmq_plugin_impl::add_pub_keys( const vector<chain::key_weight>& keys, const account_name& name,
                                         const permission_name& permission, const std::chrono::milliseconds& now )
{

   if( keys.empty()) return;

   for( const auto& pub_key_weight : keys ) {
   	pub_key_struct pks;
	pks.account = name.to_string();
	pks.public_key = pub_key_weight.key.operator string();
	pks.permission = permission.to_string();
   

   	try {
	 auto  pks_json = "pubkey " + fc::json::to_string(pks);
	 zmq::message_t message(pks_json.size());
	 memcpy (message.data(), pks_json.data(), pks_json.size());
	 publisher->send(message);
   	} catch (...) {
   
   	}
   }
}
void zmq_plugin_impl::update_account(const chain::action& act)
{

   if (act.account != chain::config::system_account_name)
      return;

   try {
      if( act.name == newaccount ) {
         std::chrono::milliseconds now = std::chrono::duration_cast<std::chrono::milliseconds>(
               std::chrono::microseconds{fc::time_point::now().time_since_epoch().count()} );
         auto newacc = act.data_as<chain::newaccount>();
         add_pub_keys( newacc.owner.keys, newacc.name, owner, now );
         add_pub_keys( newacc.active.keys, newacc.name, active, now );

      } else if( act.name == updateauth ) {
         auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
               std::chrono::microseconds{fc::time_point::now().time_since_epoch().count()} );
         const auto update = act.data_as<chain::updateauth>();
         add_pub_keys(update.auth.keys, update.account, update.permission, now);

      } else if( act.name == deleteauth ) {
         const auto del = act.data_as<chain::deleteauth>();

      } else if( act.name == setabi ) {
         auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
               std::chrono::microseconds{fc::time_point::now().time_since_epoch().count()} );
         auto setabi = act.data_as<chain::setabi>();


      }
   } catch( fc::exception& e ) {
      // if unable to unpack native type, skip account creation
   }
}

zmq_plugin_impl::zmq_plugin_impl() //:context(1),publisher(zmq::socket_t(context, ZMQ_PUB)){
{
 
}

zmq_plugin_impl::~zmq_plugin_impl() {
	// delete context;
	delete publisher;
   if (!startup) {
      try {
         ilog( "zmq_plugin shutdown in process please be patient this can take a few minutes" );
         done = true;
         condition.notify_one();

         consume_thread.join();

      } catch( std::exception& e ) {
         elog( "Exception on zmq_plugin shutdown of consume thread: ${e}", ("e", e.what()));
      }
   }
}

void zmq_plugin_impl::init() {
   // Create the native contract accounts manually; sadly, we can't run their contracts to make them create themselves
   // See native_contract_chain_initializer::prepare_database()

   ilog("init zmq");
   ilog("starting db plugin thread");

   consume_thread = boost::thread([this] { consume_blocks(); });

   startup = false;
}









zmq_plugin::zmq_plugin():my(new zmq_plugin_impl()){}
zmq_plugin::~zmq_plugin(){}

void zmq_plugin::set_program_options(options_description&, options_description& cfg) {
   cfg.add_options()
         ("zmq-addr", bpo::value<string>()->default_value("localhost:4321"),
          "zero mq pub socket address")
         ("zmq-store-table", bpo::value<string>()->default_value("eosio:voters"),
          "the table to share, format is <contract account>:<table name>, the info is listed in abi code, pls refer to that.")
         ("zmq-block-start", bpo::value<uint32_t>()->default_value(0),
          "If specified then on data pushed to zmq until specified block is reached.")
         ("zmq-store-blocks", bpo::value<bool>()->default_value(true),
          "Enables storing blocks to zmq.")
         ("zmq-store-block-states", bpo::value<bool>()->default_value(true),
          "Enables storing block states to zmq.")
         ("zmq-store-transactions", bpo::value<bool>()->default_value(true),
          "Enables storing transactions to zmq.")
         ("zmq-store-transactions-traces", bpo::value<bool>()->default_value(true),
          "Enables storing transaction traces to zmq.")
         ("zmq-store-action-traces", bpo::value<bool>()->default_value(true),
          "Enables storing action traces to zmq.")
         ;
}

void zmq_plugin::plugin_initialize(const variables_map& options) {
   try {
      if( options.count( "zmq-addr" ) == 0) {
         // Handle the option
	 wlog("zmq-addr must be specified when enabling plugin zmq");
	 return ;
      }
      if( options.count( "zmq-store-table" ) == 0) {
         // Handle the option
	 my->is_store_table = false;

      }else{
      	 my->is_store_table = true;
	 // to do 
      }
      if( options.count( "zmq-block-start" ) == 0) {
         // Handle the option
	 my->start_block_num = 0;
      }else{
      	 my->start_block_num = options.at( "zmq-block-start" ).as<uint32_t>();
      }
      if( options.count( "zmq-store-blocks" ) ) {
         // Handle the option
	 my->store_blocks = options.at( "zmq-store-blocks" ).as<bool>();
      }else{
	       my->store_blocks = false;
      }
      if( options.count( "zmq-store-block-states" )) {
         // Handle the option
	 my->store_block_states = options.at( "zmq-store-block-states" ).as<bool>();
      }else {
      	 my->store_block_states = false;
      }
      if( options.count( "zmq-store-transactions" ) ) {
         // Handle the option
	 my->store_transactions = options.at( "zmq-store-transactions" ).as<bool>();
      }else {
      	 my->store_transactions = false;
      }
      if( options.count( "zmq-store-transaction-traces" ) ) {
         // Handle the option
	 my->store_transaction_traces = options.at( "zmq-store-transaction-traces" ).as<bool>();
      }else {
      	 my->store_transaction_traces = false;
      }
      if( options.count( "zmq-store-action-traces" ) ) {
         // Handle the option
	 my->store_action_traces = options.at( "zmq-store-action-traces" ).as<bool>();
      }else {
      	 my->store_action_traces = false;
      }
      if( options.count( "producer-name" ) ) {
         // Handle the option
	 wlog( "zmq plugin not recommended on producer node" );
	 my->is_producer = true;
      }
      if( my->start_block_num == 0 ) {
         my->start_block_reached = true;
      }
      std::string addr_str = options.at( "zmq-addr" ).as<std::string>();

	ilog("connecting to ${u}", ("u",addr_str));
	// my->publisher.bind("tcp://" + addr_str);
	// try{
	auto context = zmq::context_t(1);
	my->publisher = new zmq::socket_t(context , ZMQ_PUB);
	my->publisher->bind(addr_str);

	std::string topic_base = "EOS";

	chain_plugin* chain_plug = app().find_plugin<chain_plugin>();
	EOS_ASSERT( chain_plug, chain::missing_chain_plugin_exception, ""  );
	auto& chain = chain_plug->chain();
        my->chain_id.emplace( chain.get_chain_id());

	my->accepted_block_connection.emplace( chain.accepted_block.connect( [&]( const chain::block_state_ptr& bs ) {
		my->accepted_block( bs );
	} ));
	my->irreversible_block_connection.emplace(
		chain.irreversible_block.connect( [&]( const chain::block_state_ptr& bs ) {
			my->applied_irreversible_block( bs );
	} ));
	my->accepted_transaction_connection.emplace(
		chain.accepted_transaction.connect( [&]( const chain::transaction_metadata_ptr& t ) {
			my->accepted_transaction( t );
		} ));
	my->applied_transaction_connection.emplace(
			chain.applied_transaction.connect( [&]( const chain::transaction_trace_ptr& t ) {
				my->applied_transaction( t );
	} ));
	my->init();
   }
   FC_LOG_AND_RETHROW()
}

void zmq_plugin::plugin_startup() {
   // Make the magic happen
}

void zmq_plugin::plugin_shutdown() {
   // OK, that's enough magic
        my->accepted_block_connection.reset();
        my->irreversible_block_connection.reset();
        my->accepted_transaction_connection.reset();
	my->applied_transaction_connection.reset();
	my.reset();
}

}

FC_REFLECT( eosio::zmq_plugin_impl::pub_key_struct, (account)(public_key)(permission) )
FC_REFLECT( eosio::zmq_plugin_impl::action_trace_struct, (base)(trx_status) )
